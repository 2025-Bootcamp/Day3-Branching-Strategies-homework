# Git Aoneflow 分支策略Homework

按照**Aoneflow 分支策略**进行评估，为验证每个分支及提交，请保留所有分支并推送至远端仓库。

点击此项目的 Fork，然后再进行 Clone。

## 分支策略说明

- **master**: 主分支，用于生产环境
- **release**: 发布分支，用于集成测试和预发布
- **feature**: 功能分支，用于开发新功能

## 场景一：基础功能开发与冲突处理

### 第1步：开发需求 A1 和 A2

开发需求 A1，创建 A1.txt 文件，并插入内容：
```
这是 A1 需求的基础功能
```

开发需求 A2，创建 A2.txt 文件，并插入内容：
```
这是 A2 需求的基础功能
```

### 第2步：创建 release 分支进行集成

将 A1 和 A2 合并到 release 分支进行集成测试。

### 第3步：A1 需求变更

在 A1 分支上修改 A1.txt 文件：
```
这是 A1 需求的基础功能
这是 A1 需求的增强功能
```

### 第4步：处理冲突

此时，我们直接在release分支也修改 A1.txt 文件（模拟冲突）：
```
这是 A1 需求的基础功能
这是 release 分支直接对 A1 的修改
```

解决冲突，保留两个修改：
```
这是 A1 需求的基础功能
这是 release 分支直接对 A1 的修改
这是 A1 需求的增强功能
```

### 第5步：完成上线

迭代目标完成，完成上线后打 Tag 为 v1.0。

## 场景二：并行开发与回滚

### 第1步：开发需求 B1 和 B2

开发需求 B1，创建 B1.txt 文件：
```
这是 B1 需求
```

开发需求 B2，创建 B2.txt 文件：
```
这是 B2 需求
```

### 第2步：B1 需求变更

修改 B1.txt 文件：
```
这是 B1 需求
这是 B1 需求的第二版
```

### 第3步：B2 需求变更

修改 B2.txt 文件：
```
这是 B2 需求
这是 B2 需求的第二版
```

### 第4步：B1 回滚

发现 B1 的第二版有问题，需要回滚到第一版。

### 第5步：集成测试

将 B1（回滚后）和 B2 进行集成测试。

### 第6步：完成上线

迭代目标完成，完成上线后打 Tag 为 v2.0。

## 场景三：复杂冲突与紧急修复

### 第1步：开发需求 C1、C2、C3

开发需求 C1，创建 C1.txt：
```
这是 C1 需求
```

开发需求 C2，创建 C2.txt：
```
这是 C2 需求
```

开发需求 C3，创建 C3.txt：
```
这是 C3 需求
```

### 第2步：C1 和 C2 同时修改 C3

C1 分支修改 C3.txt：
```
这是 C3 需求
这是 C1 对 C3 的修改
```

C2 分支修改 C3.txt：
```
这是 C3 需求
这是 C2 对 C3 的修改
```

### 第3步：解决三向冲突

将 C1、C2、C3 合并到 release 分支，解决冲突：
```
这是 C3 需求
这是 C1 对 C3 的修改
这是 C2 对 C3 的修改
```

### 第4步：生产环境紧急修复

生产环境发现 A1.txt 有严重 bug，需要紧急修复。

创建 hotfix 分支，修改 A1.txt：
```
这是 A1 需求的基础功能
这是 A1 需求的增强功能
这是 A2 对 A1 的修改
这是紧急修复 A1 的 bug
```

### 第5步：紧急上线

完成紧急修复，直接合并到 master 并打 Tag 为 v2.1。

### 第6步：继续正常迭代

将 C1、C2、C3 的集成结果合并到 master，完成上线后打 Tag 为 v3.0。

## 场景四：分支策略验证

### 第1步：开发需求 D1

开发需求 D1，创建 D1.txt：
```
这是 D1 需求
```

### 第2步：D1 多次变更

第一次修改 D1.txt：
```
这是 D1 需求
这是 D1 的第一次修改
```

第二次修改 D1.txt：
```
这是 D1 需求
这是 D1 的第一次修改
这是 D1 的第二次修改
```

### 第3步：D1 部分回滚

回滚 D1 的第二次修改，保留第一次修改。

### 第4步：完成上线

迭代目标完成，完成上线后打 Tag 为 v4.0。

## 场景五：复杂合并策略

### 第1步：开发需求 E1 和 E2

开发需求 E1，创建 E1.txt：
```
这是 E1 需求
```

开发需求 E2，创建 E2.txt：
```
这是 E2 需求
```

### 第2步：E1 和 E2 相互依赖

E1 需要修改 E2.txt：
```
这是 E2 需求
这是 E1 对 E2 的依赖修改
```

E2 需要修改 E1.txt：
```
这是 E1 需求
这是 E2 对 E1 的依赖修改
```

### 第3步：解决循环依赖

通过合理的合并顺序解决循环依赖问题。

### 第4步：完成上线

迭代目标完成，完成上线后打 Tag 为 v5.0。

## 验证结果

### 1. 执行 `git tag` 命令，结果为：
```
v1.0
v2.0
v2.1
v3.0
v4.0
v5.0
```

### 2. 执行 `ls` 命令结果为：
```
A1.txt   A2.txt   B1.txt   B2.txt   C1.txt   C2.txt   C3.txt   D1.txt   E1.txt   E2.txt   README.md
```

### 3. 执行 `git branch -a` 命令，应包含以下分支：
```
master
release
feature/A1
feature/A2
feature/B1
feature/B2
feature/C1
feature/C2
feature/C3
feature/D1
feature/E1
feature/E2
hotfix/A1-bug
```

## 评分标准

1. **分支操作正确性** (30分)
   - 正确创建 feature 分支
   - 正确创建 release 分支
   - 分支命名规范

2. **合并操作正确性** (25分)
   - 正确合并到 release 分支
   - 正确合并到 master 分支
   - 合并顺序合理

3. **冲突处理能力** (25分)
   - 正确识别冲突
   - 合理解决冲突
   - 保留必要的修改

4. **回滚操作正确性** (20分)
   - 正确回滚到指定版本
   - 回滚后状态正确
   - 不影响其他分支

## 提交要求

1. 所有分支必须保留并推送到远端仓库
2. 每个场景的提交信息要清晰明确
3. 冲突解决要保留所有必要的修改
4. 回滚操作要使用正确的 Git 命令
5. 最终验证结果要完全匹配预期 
